# JAVASCRIPT

## Введение в события
События — это действия или события, происходящие в системе, которую вы программируете, о которых система сообщает вам, чтобы ваш код мог реагировать на них.

В случае Интернета события запускаются внутри окна браузера и, как правило, привязаны к определенному элементу, который находится в нем. Это может быть отдельный элемент, набор элементов, HTML-документ, загруженный на текущей вкладке, или все окно браузера. Возможны различные типы событий.

Например:

  - Пользователь выбирает, щелкает или наводит курсор на определенный элемент.
  - Пользователь выбирает клавишу на клавиатуре.
  - Пользователь изменяет размер или закрывает окно браузера.
  - Веб-страница завершает загрузку.
  - Отправляется форма.
  - Видео воспроизводится, приостанавливается или завершается.
  - Возникает ошибка.

Вы можете понять из этого (и из [справочника](https://developer.mozilla.org/en-US/docs/Web/Events) событий MDN), что существует множество событий, которые могут быть запущены.

Чтобы отреагировать на событие, вы прикрепляете к нему **обработчик событий** (event handler) . Это блок кода (обычно это функция JavaScript, которую вы, как программист, создаете), который запускается при возникновении события. Когда такой блок кода определен для запуска в ответ на событие, мы говорим, что **регистрируем обработчик события**. Примечание. Обработчики событий иногда называют **прослушивателями событий** (event listener) — для наших целей они в значительной степени взаимозаменяемы, хотя, строго говоря, они работают вместе. Слушатель прослушивает происходящее событие, а обработчик — это код, который запускается в ответ на это событие.

> *Примечание*: Веб-события не являются частью основного языка JavaScript — они определяются как часть API, встроенных в браузер.

### Простой пример
Давайте посмотрим на простой пример того, что мы имеем в виду. В следующем примере у нас есть один `<button>`, при нажатии которого фон меняется на случайный цвет:

```
<button>Change color</button>
```


JavaScript выглядит так:

```
const btn = document.querySelector('button');

function random(number) {
  return Math.floor(Math.random() * (number+1));
}

function changeBackground() {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  document.body.style.backgroundColor = rndCol;
}
```

В этом коде мы сохраняем ссылку на `<button>` элемент внутри константы с именем btn, используя `Document.querySelector()` функцию.

Мы также определяем функцию, которая возвращает случайное число.

### Использование `addEventListener()`

Рекомендуемым механизмом добавления обработчиков событий на веб-страницы является метод `addEventListener()`:

```
const btn = document.querySelector('button');

function random(number) {
  return Math.floor(Math.random() * (number+1));
}

function changeBackground() {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  document.body.style.backgroundColor = rndCol;
}

btn.addEventListener('click', changeBackground);
```

Внутри функции `addEventListener()` мы указываем два параметра: имя события, для которого мы хотим зарегистрировать этот обработчик, и код, содержащий функцию-обработчик, которую мы хотим запустить в ответ на него.

Можно сделать функцию-обработчик и анонимной функцией.

 События не уникальны для JavaScript — в большинстве языков программирования есть какая-то модель событий, и способ работы этой модели часто отличается от того, как работает JavaScript. На самом деле модель событий в JavaScript для веб-страниц отличается от модели событий для JavaScript, поскольку она используется в других средах.

### Прослушивание других событий

Существует множество различных событий, которые могут быть запущены элементом кнопки. Давайте экспериментировать.

Сначала сделайте локальную копию random-color-addeventlistener.html и откройте ее в браузере. Это просто копия простого примера случайного цвета, с которым мы уже играли. Теперь попробуйте `click` по очереди изменить следующие значения и понаблюдайте за результатами в примере:

  - `focus` и `blur` — цвет меняется, когда кнопка сфокусирована и не сфокусирована; попробуйте нажать вкладку, чтобы сфокусироваться на кнопке, и снова нажать вкладку, чтобы сфокусироваться от кнопки. Они часто используются для отображения информации о заполнении полей формы, когда они находятся в фокусе, или отображения сообщения об ошибке, если поле формы заполнено неправильным значением.
 - `dblclick` — Цвет меняется только при двойном нажатии кнопки.
 - `mouseover` и `mouseout` — цвет изменяется при наведении указателя мыши на кнопку или при перемещении указателя с кнопки соответственно.

Некоторые события, такие как `click`, доступны практически для любого элемента. Другие более специфичны и полезны только в определенных ситуациях: например, событие `play` доступно только для некоторых элементов, таких как `<video>`.

### Удаление слушателей

Если вы добавили обработчик событий с помощью `addEventListener()`, вы можете снова удалить его с помощью метода `removeEventListener()`. Например, это удалит обработчик `changeBackground()`:

```
btn.removeEventListener('click', changeBackground);
```

Обработчики событий также можно удалить, передав объект `AbortSignal` в `addEventListener()`, а затем при вызове `abort()` у контроллера, владеющего `AbortSignal`. Например, чтобы добавить обработчик событий, который мы можем удалить с помощью `AbortSignal`:

```
const controller = new AbortController();

btn.addEventListener('click', () => {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  document.body.style.backgroundColor = rndCol;
}, { signal: controller.signal }); // pass an AbortSignal to this handler
```

Затем обработчик событий, созданный приведенным выше кодом, можно удалить следующим образом:

```
controller.abort(); // removes any/all event handlers associated with this controller
```

Для простых, небольших программ очистка старых, неиспользуемых обработчиков событий не требуется, но для более крупных и сложных программ это может повысить эффективность. Кроме того, возможность удалять обработчики событий позволяет использовать одну и ту же кнопку для выполнения разных действий в разных обстоятельствах: все, что вам нужно сделать, это добавить или удалить обработчики.

### Добавление нескольких прослушивателей для одного события

Делая более одного вызова `addEventListener()` и предоставляя разные обработчики, вы можете иметь несколько обработчиков для одного события:

```
myElement.addEventListener('click', functionA);
myElement.addEventListener('click', functionB);
```

Обе функции теперь будут запускаться при нажатии на элемент.

**Изучайте больше**

Существуют и другие мощные функции и параметры, доступные в `addEventListener()`, для этого посетите страницы [addEventListener()](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener) и [removeEventListener()](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener).

## Другие механизмы прослушивания событий
В общем рекомендуется использовать `addEventListener()` для регистрации обработчиков событий. Это самый мощный метод, который лучше всего подходит для более сложных программ. Однако есть два других способа регистрации обработчиков событий, которые вы можете использовать: *свойства обработчика* событий и *встроенные обработчики событий*.

## Свойства обработчика событий
Объекты (например, кнопки), которые могут запускать события, также обычно имеют свойства, за именем которых `on` следует имя события. Например, элементы имеют свойство `onclick`. Это называется свойством обработчика событий. Чтобы прослушать событие, вы можете назначить функцию-обработчик свойству.

Например, мы могли бы переписать пример со случайным цветом следующим образом:

```
const btn = document.querySelector('button');

function random(number) {
  return Math.floor(Math.random() * (number+1));
}

btn.onclick = () => {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  document.body.style.backgroundColor = rndCol;
}
```

Вы также можете установить свойство обработчика на именованную функцию:

```
const btn = document.querySelector('button');

function random(number) {
  return Math.floor(Math.random() * (number+1));
}

function bgChange() {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  document.body.style.backgroundColor = rndCol;
}

btn.onclick = bgChange;
```

С помощью свойств обработчика событий вы не можете добавить более одного обработчика для одного события. Например, вы можете вызывать `addEventListener('click', handler)` элемент несколько раз с разными функциями, указанными во втором аргументе:

```
element.addEventListener('click', function1);
element.addEventListener('click', function2);
```

Это невозможно со свойствами обработчика событий, потому что любые последующие попытки установить свойство перезапишут более ранние:

```
element.onclick = function1;
element.onclick = function2;
```

### Встроенные обработчики событий — не используйте их
Вы также можете увидеть подобный шаблон в своем коде:

```
<button onclick="bgChange()">Press me</button>
```

```
function bgChange() {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  document.body.style.backgroundColor = rndCol;
}
```

Самый ранний метод регистрации обработчиков событий, найденный в Интернете, включал HTML-атрибуты обработчика событий (или встроенные обработчики событий), подобные показанному выше — значением атрибута буквально является код JavaScript, который вы хотите запустить при возникновении события. В приведенном выше примере вызывается функция, определенная внутри элемента `<script>` на той же странице, но вы также можете вставить JavaScript непосредственно в атрибут, например:

```
<button onclick="alert('Hello, this is my old-fashioned event handler!');">Press me</button>
```

Вы можете найти эквиваленты атрибутов HTML для многих свойств обработчиков событий; однако вы не должны использовать их — это считается плохой практикой. Может показаться простым использовать атрибут обработчика событий, если вы делаете что-то очень быстро, но они быстро становятся неуправляемыми и неэффективными.

Для начала не рекомендуется смешивать HTML и JavaScript, так как их становится трудно читать. Хранение вашего JavaScript отдельно является хорошей практикой, и если он находится в отдельном файле, вы можете применить его к нескольким HTML-документам.

Даже в одном файле встроенные обработчики событий — не лучшая идея. Одна кнопка — это нормально, но что, если бы у вас было 100 кнопок? Вам нужно будет добавить в файл 100 атрибутов; это быстро превратилось бы в кошмар обслуживания. С помощью JavaScript вы можете легко добавить функцию обработчика событий ко всем кнопкам на странице, сколько бы их ни было, используя что-то вроде этого:

```
const buttons = document.querySelectorAll('button');

for (const button of buttons) {
  button.addEventListener('click', bgChange);
}
```

Наконец, многие распространенные конфигурации серверов запрещают встроенный JavaScript в качестве меры безопасности.

**Вы никогда не должны использовать атрибуты обработчика событий HTML** — они устарели, и их использование — плохая практика.

## Объекты событий
Иногда внутри функции обработчика событий вы увидите параметр, указанный с таким именем, как `event`, `evt` или `e`. Он называется объектом события и автоматически передается обработчикам событий для предоставления дополнительных функций и информации. Например, давайте снова немного перепишем наш случайный пример цвета:

```
const btn = document.querySelector('button');

function random(number) {
  return Math.floor(Math.random() * (number+1));
}

function bgChange(e) {
  const rndCol = `rgb(${random(255)}, ${random(255)}, ${random(255)})`;
  e.target.style.backgroundColor = rndCol;
  console.log(e);
}

btn.addEventListener('click', bgChange);
```

Здесь вы можете видеть, что мы включаем объект события, `e` , в функцию и в функцию, устанавливающую стиль цвета фона, `e.target` который является самой кнопкой. Свойство `target` объекта события всегда является ссылкой на элемент, с которым произошло событие. Итак, в этом примере мы устанавливаем случайный цвет фона для кнопки, а не для страницы.

### Дополнительные свойства объектов событий
Большинство объектов событий имеют стандартный набор свойств и методов, доступных для объекта события (полный список см. в [справочнике](https://developer.mozilla.org/en-US/docs/Web/API/Event) по объектам).

Некоторые объекты событий добавляют дополнительные свойства, относящиеся к этому конкретному типу событий. Например, событие `keydown` срабатывает, когда пользователь нажимает клавишу. Его объект события`KeyboardEvent` —  это специализированный `Event` объект со свойством `key`, сообщающим, какая клавиша была нажата:

```
<input id="textBox" type="text">
<div id="output"></div>
```

```
const textBox = document.querySelector("#textBox");
const output = document.querySelector("#output");
textBox.addEventListener('keydown', (event) => output.textContent = `You pressed "${event.key}".`);
```

Попробуйте ввести текст в текстовое поле и посмотрите вывод.

### Предотвращение поведения по умолчанию
Иногда вы столкнетесь с ситуацией, когда вы хотите, чтобы событие не выполняло то, что оно делает по умолчанию. Наиболее распространенным примером является веб-форма, например, пользовательская регистрационная форма. Когда вы вводите данные и нажимаете кнопку «Отправить», естественным поведением является отправка данных на указанную страницу на сервере для обработки, а браузер перенаправляется на какую-либо страницу «сообщения об успешном завершении» (или той же странице, если не указан другой.)

Проблема возникает, когда пользователь не отправил данные правильно — как разработчик, вы хотите предотвратить отправку на сервер и выдать сообщение об ошибке, говорящее, что не так и что нужно сделать, чтобы все исправить. Некоторые браузеры поддерживают функции автоматической проверки данных формы, но, поскольку многие из них этого не делают, рекомендуется не полагаться на них и реализовать собственные проверки проверки. Давайте рассмотрим простой пример.

Во-первых, простая HTML-форма, которая требует ввода вашего имени и фамилии:

```
<form>
  <div>
    <label for="fname">First name: </label>
    <input id="fname" type="text">
  </div>
  <div>
    <label for="lname">Last name: </label>
    <input id="lname" type="text">
  </div>
  <div>
     <input id="submit" type="submit">
  </div>
</form>
<p></p>
```

Теперь немного JavaScript — здесь мы реализуем очень простую проверку внутри обработчика события `submit` (событие отправки запускается в форме при ее отправке), которая проверяет, пусты ли текстовые поля. Если это так, мы вызываем функцию `preventDefault()` объекта события, которая останавливает отправку формы, а затем отображаем сообщение об ошибке в абзаце под нашей формой, чтобы сообщить пользователю, что не так:

```
const form = document.querySelector('form');
const fname = document.getElementById('fname');
const lname = document.getElementById('lname');
const para = document.querySelector('p');

form.addEventListener('submit', (e) => {
  if (fname.value === '' || lname.value === '') {
    e.preventDefault();
    para.textContent = 'You need to fill in both names!';
  }
});
```

Очевидно, что это довольно слабая проверка формы — она не помешает пользователю проверять форму, например, с пробелами или числами, введенными в поля, — но для примера это нормально.

### Всплывание и захват событий
Всплывающие события и захват — это термины, описывающие этапы обработки браузером событий, направленных на вложенные элементы.

**Установка слушателя на родительском элементе**

Рассмотрим такую ​​веб-страницу:

```
<div id="container">
  <button>Click me!</button>
</div>
<pre id="output"></pre>
```

Здесь кнопка находится внутри другого элемента `<div>`. Мы говорим, что `<div>` элемент здесь является родителем элемента, который он содержит. Что произойдет, если мы добавим обработчик события клика к родителю, а затем нажмем кнопку?

```
const output = document.querySelector('#output');
function handleClick(e) {
  output.textContent += `You clicked on a ${e.currentTarget.tagName} element\n`;
}

const container = document.querySelector('#container');
container.addEventListener('click', handleClick);
```

Вы увидите, что родитель запускает событие щелчка, когда пользователь нажимает кнопку:

```
You clicked on a DIV element
```

Это имеет смысл: кнопка находится внутри `<div>`, поэтому, когда вы нажимаете кнопку, вы также неявно щелкаете элемент, внутри которого она находится.

**Пример всплывающего окна**

Что произойдет, если мы добавим прослушиватели событий к кнопке и родителю?

```
<body>
  <div id="container">
    <button>Click me!</button>
  </div>
  <pre id="output"></pre>
</body>
```

Давайте попробуем добавить обработчики событий клика к кнопке, ее родителю ( `<div>`) и элементу `<body>`, содержащему их оба:

```
const output = document.querySelector('#output');
function handleClick(e) {
  output.textContent += `You clicked on a ${e.currentTarget.tagName} element\n`;
}

const container = document.querySelector('#container');
const button = document.querySelector('button');

document.body.addEventListener('click', handleClick);
container.addEventListener('click', handleClick);
button.addEventListener('click', handleClick);
```

Вы увидите, что все три элемента запускают событие клика, когда пользователь нажимает кнопку:

```
You clicked on a BUTTON element
You clicked on a DIV element
You clicked on a BODY element
```

В таком случае:

  - нажатие на кнопку срабатывает первым
  - с последующим щелчком по его родителю ( <div>элементу)
  - за которым <div>следует родитель элемента ( <body>элемент).

Мы описываем это, говоря, что событие всплывает (bubbles) из самого внутреннего элемента, по которому был сделан щелчок.

Такое поведение может быть полезным, а также может вызвать непредвиденные проблемы. В следующем разделе мы увидим проблему, которую она вызывает, и найдем решение.

**Пример видеоплеера**

Этот пример показывает и скрывает `<div>` с `<video>` элементом внутри него:

```
 <style>
      div {
        position: absolute;
        top: 50%;
        transform: translate(-50%,-50%);
        width: 480px;
        height: 380px;
        border-radius: 10px;
        background-color: #eee;
        background-image: linear-gradient(to bottom, rgba(0,0,0,0), rgba(0,0,0,0.1));
      }

      .hidden {
        left: -50%;
      }

      .showing {
        left: 50%;
      }

      div video {
        display: block;
        width: 400px;
        margin: 40px auto;
      }

    </style>

<button>Display video</button>

<div class="hidden">
  <video>
    <source src="https://raw.githubusercontent.com/mdn/learning-area/master/javascript/building-blocks/events/rabbit320.mp4" type="video/mp4">
    <source src="https://raw.githubusercontent.com/mdn/learning-area/master/javascript/building-blocks/events/rabbit320.webm" type="video/webm">
    <p>Your browser doesn't support HTML5 video. Here is a <a href="rabbit320.mp4">link to the video</a> instead.</p>
  </video>
</div>
```

Когда `<button>` щелкают, видео отображается путем изменения атрибута `class` в `<div>` с `hidden` на `showing` (CSS примера содержит эти два класса, которые размещают блок за пределами экрана и на экране соответственно):

```
const btn = document.querySelector('button');
const videoBox = document.querySelector('div');

function displayVideo() {
  if (videoBox.getAttribute('class') === 'hidden') {
    videoBox.setAttribute('class','showing');
  }
}

btn.addEventListener('click', displayVideo);
```

Затем мы добавляем еще пару обработчиков событий `click` — первый к `<div>`, а второй к `<video>`:

```
videoBox.addEventListener('click', () => videoBox.setAttribute('class', 'hidden'));

const video = document.querySelector('video');

video.addEventListener('click', () => video.play());
```

Теперь, когда щелкнут область за пределами `<div>` видео, поле должно снова быть скрыто, а когда щелкнут само видео, видео должно начать воспроизводиться.

Но есть проблема — в настоящее время, когда вы нажимаете на видео, оно начинает воспроизводиться, но `<div>` в то же время скрывается. Это связано с тем, что видео находится внутри `<div>` — оно является его частью — поэтому нажатие на видео фактически запускает оба вышеуказанных обработчика событий.

**Объяснение всплытия и захвата**

Когда событие запускается для элемента, у которого есть родительские элементы (в данном случае, у элемента `<video>` есть родитель `<div>`), современные браузеры выполняют три разных этапа — этап **захвата** (capturing phase), этап **таргетирования** (target phase) и этап **всплытия** (bubbling phase).

На этапе **захвата** :

  - Браузер проверяет, зарегистрирован ли на самом внешнем предке элемента ( `<html>`) обработчик событий `click` для фазы захвата, и запускает его, если это так.
  - Затем он переходит к следующему элементу внутри <html>и делает то же самое, затем к следующему и так далее, пока не достигнет прямого родителя элемента, по которому фактически был сделан щелчок.

В **целевой** фазе:

  - Браузер проверяет, есть ли у свойства `target` обработчик событий для `click` и запускает его, если это так.
  - Затем, если `bubbles` равно `true`, событие передается непосредственному родителю выбранного элемента, затем следующему и так далее, пока не достигнет `<html>` элемента. В противном случае, если `bubbles` равен false, событие не передается никаким предкам цели.

В фазе **всплытия** происходит полная противоположность фазе захвата :

  - Браузер проверяет, зарегистрирован ли обработчик событий `click` для непосредственного родителя выбранного элемента, и запускает его, если это так.
  - Затем он переходит к следующему непосредственному элементу-предку и делает то же самое, затем к следующему и так далее, пока не достигнет `<html>` элемента.

В современных браузерах по умолчанию все обработчики событий регистрируются для фазы всплытия. Таким образом, в нашем текущем примере, когда вы нажимаете на видео, событие всплывает от `<video>` элемента наружу к `<html>` элементу. По пути:

  - Он находит обработчик `click` `video` элемента и запускает его, поэтому сначала начинает воспроизводиться видео.
  - Затем он находит обработчик `click` `videoBox` элемента и запускает его, поэтому видео также скрывается.
